const bcrypt = require("bcryptjs");
var jwt = require("jsonwebtoken");
const express = require("express");
const ls = require("local-storage");
const User = require("../model/user");

const router = express.Router();

const JWTSecret = process.env.JWTSecret; //our jwt signature(random string generated by us)

function capitalize(s) {
	return s[0].toUpperCase() + s.slice(1).toLowerCase();
}

router.post("/createUser", async (req, res) => {
	try {
		let user = await User.findOne({ email: req.body.email }); //searching user with same email

		if (user) {
			return res
				.status(400)
				.json({ msg: "User already exists with same email", success: "false" });
		}

		const salt = await bcrypt.genSaltSync(10); //generating salt
		const hash = await bcrypt.hashSync(req.body.password, salt); //hashing the password
		let team = req.body.team.split(",");

		for (let i = 0; i < team.length; i++) {
			team[i] = capitalize(team[i]);
		}
		user = await User.create({
			//boiler plate code from express-validator website
			team,
			email: req.body.email,
			password: hash, //storing the hashed password
		});

		/* will use jwt web token to identify all authentic user ,for jwt we need id of the user & a seckret sign*/

		//user id ,we are using for jwt
		const data = {
			user: {
				email: user.email,
			},
		};

		const authToken = jwt.sign(data, JWTSecret); //jwtSecret is our own signature,it will help us to identify user
		ls.set("token", authToken);
		res.redirect("/");
	} catch (err) {
		console.error(err);
		res
			.status(500)
			.send({ msg: "some internal error occure", success: "false" });
	}
});
router.get("/signout", (req, res) => {
	ls.clear("token");
	res.redirect("/");
});
router.post("/signin", async (req, res) => {
	const { email } = req.body;
	const user = await User.findOne({ email });
	if (!user) {
		return res.status(403).json({ msg: "please put valid credentials" });
	}
	const passwordCompare = await bcrypt.compare(
		req.body.password,
		user.password
	);

	if (!passwordCompare) {
		return res
			.status(500)
			.json({ success: "false", msg: "please put valid credentials" });
	}

	const data = {
		user: {
			email: user.email,
		},
	};

	const authToken = jwt.sign(data, JWTSecret);
	ls.set("token", authToken);
	res.redirect("/");
});
router.post("/updateUser", async (req, res) => {
	let { email, team } = req.body;
	if (email === undefined)
		return res.json({ msg: "Sorry can't perform update" });
	team = team.split(",");
	for (let i = 0; i < team.length; i++) {
		team[i] = capitalize(team[i]);
	}
	await User.findOneAndUpdate({ email }, { team });
	res.redirect("/");
});

router.post("/changePassword", async (req, res) => {
	const { old, password, confirm, email } = req.body;
	if (password !== confirm)
		return res.json({ msg: "password & confirm password are not same" });
	const user = await User.findOne({ email });
	if (user === undefined) {
		return res.status(403).json({ msg: "please put valid credentials" });
	}
	const passwordCompare = await bcrypt.compare(req.body.old, user.password);
	if (passwordCompare === false)
		return res.json({ msg: "password didn't match" });
	const salt = bcrypt.genSaltSync(10); //generating salt
	const hash = bcrypt.hashSync(req.body.password, salt);
	await User.findOneAndUpdate({ email }, { password: hash });
	res.redirect("/");
});

module.exports = router;
