const bcrypt = require("bcryptjs");
var jwt = require("jsonwebtoken");
const express=require('express')
const ls = require('local-storage')
const User=require('../model/user')

const router=express.Router()


const JWTSecret = "$$You are not $welcome&&#";//our jwt signature(random string generated by us)

router.post('/createUser',async (req,res)=>{
  try{
  let {email,password,team}=req.body
  let user = await User.findOne({ email: req.body.email }); //searching user with same email

      if (user) {
        return res
          .status(400)
          .json({ msg: "User already exists with same email" ,success:"false"});
      }

      const salt = await bcrypt.genSaltSync(10); //generating salt
      const hash = await bcrypt.hashSync(req.body.password, salt); //hashing the password
      user = await User.create({
        //boiler plate code from express-validator website
        team:req.body.team.split(','),
        email: req.body.email,
        password: hash, //storing the hashed password
      });


      /* will use jwt web token to identify all authentic user ,for jwt we need id of the user & a seckret sign*/

      //user id ,we are using for jwt 
      const data = {
        user: {
          email: user.email,
        },
      };

      const authToken = jwt.sign(data, JWTSecret);//jwtSecret is our own signature,it will help us to identify user 
      ls.set('token',authToken)
      res.redirect('/')
    } catch (err) {
      console.error(err);
      res.status(500).send({msg:"some internal error occure",success:"false"})
    }
})
router.get('/signout',(req,res)=>{
  ls.clear('token')
  res.redirect('/')
})
router.post('/signin',async (req,res)=>{
  const {email,password}=req.body
  const user=await User.findOne({email})
  if (user===undefined) {
    return res
      .status(403)
      .json({ msg: "please put valid credentials" });
  }
  const passwordCompare=await bcrypt.compare(req.body.password,user.password)//compair given password & stored password,argument order is important

  if(passwordCompare===false){
    return res
      .status(500)
      .json({success:"false", msg: "please put valid credentials" });
  }
 
 
  const data = {
    user: {
      email: user.email,
    },
  };

  const authToken = jwt.sign(data, JWTSecret);
  ls.set('token',authToken)
  res.redirect('/')
  
})
router.post('/updateUser',async (req,res)=>{
  let {email,team}=req.body
  if(email===undefined)
    return res.json({msg:"Sorry can't perform update"})
  team=team.split(',')
  await User.findOneAndUpdate({email},{team})
  console.log("updated")
  res.redirect('/')
})

router.post('/changePassword',async (req,res)=>{
  const {old,password,confirm,email}=req.body
  console.log(old,password,confirm)
  if(password!==confirm)
    return res.json({msg:"password & confirm password are not same"})
  const user=await User.findOne({email})
  if (user===undefined) {
    return res
      .status(403)
      .json({ msg: "please put valid credentials" });
  }
  const passwordCompare=await bcrypt.compare(req.body.old,user.password)
  if(passwordCompare===false)
    return res.json({msg:"password didn't match"})
  const salt = await bcrypt.genSaltSync(10); //generating salt
  const hash = await bcrypt.hashSync(req.body.password, salt);  
  await User.findOneAndUpdate({email},{password:hash})
  console.log("password changed")
  res.redirect('/')
})




module.exports=router